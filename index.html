<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Random Conversations Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: monospace; color: #fff; }
    canvas { display: block; image-rendering: pixelated; }
    #dialogueBox {
      position: absolute;
      bottom: 10%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      border: 2px solid #fff;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      font-size: 14px;
      line-height: 1.4;
    }
    .dialogue-option {
      margin-top: 10px;
      padding: 5px;
      background: #222;
      border: 1px solid #fff;
      cursor: pointer;
    }
    #talkPrompt {
      position: absolute;
      font-size: 12px;
      background: rgba(0,0,0,0.7);
      padding: 2px 5px;
      border: 1px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="dialogueBox" style="display:none;"></div>
  <div id="talkPrompt" style="display:none;">E to talk</div>
  <script>
    // Set up canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Global game state: 'game' or 'dialogue'
    let gameState = 'game';
    
    // Player object
    const player = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      size: 16,
      speed: 2
    };
    
    // Camera for infinite world simulation
    let camera = { x: 0, y: 0 };
    
    // Vocabulary: 250 words to be used for generating dialogue.
    const vocabulary = [
      "hello", "goodbye", "yes", "no", "maybe", "please", "thanks", "sorry", "welcome", "friend",
      "enemy", "ally", "stranger", "hero", "villain", "brave", "bold", "cunning", "wise", "curious",
      "quest", "journey", "adventure", "danger", "challenge", "mystery", "secret", "fate", "destiny", "fortune",
      "magic", "power", "spell", "curse", "charm", "potion", "elixir", "artifact", "relic", "rune",
      "sword", "shield", "bow", "arrow", "dagger", "spear", "armor", "battle", "combat", "fight",
      "win", "lose", "victory", "defeat", "triumph", "struggle", "clash", "duel", "storm", "calm",
      "light", "dark", "shadow", "flame", "ember", "frost", "wind", "earth", "water", "fire",
      "sky", "star", "moon", "sun", "dawn", "dusk", "twilight", "horizon", "cloud", "mist",
      "castle", "dungeon", "forest", "cave", "labyrinth", "tower", "bridge", "gate", "village", "kingdom",
      "road", "path", "trail", "map", "guide", "sign", "door", "key", "lock", "treasure",
      "coin", "gold", "silver", "jewel", "gem", "wealth", "trade", "bargain", "offer", "deal",
      "whisper", "shout", "cry", "laugh", "smile", "frown", "speak", "listen", "voice", "echo",
      "dream", "nightmare", "vision", "prophecy", "omen", "hint", "riddle", "puzzle", "enigma", "tale",
      "story", "legend", "myth", "fable", "lore", "history", "memory", "truth", "lie", "promise",
      "oath", "vow", "mercy", "chance", "risk", "luck", "hope", "fear", "honor", "glory",
      "the", "a", "an", "and", "but", "or", "if", "then", "when", "where",
      "who", "what", "why", "how", "with", "without", "in", "on", "at", "by",
      "for", "from", "of", "is", "are", "was", "were", "be", "been", "being",
      "do", "does", "did", "have", "has", "had", "will", "would", "can", "could",
      "shall", "should", "may", "might", "must", "go", "come", "see", "look", "hear",
      "run", "walk", "chat", "answer", "ask", "say", "tell", "murmur", "explain", "describe",
      "reveal", "hide", "seek", "explore", "discover", "find", "uncover", "follow", "lead", "return",
      "begin", "start", "finish", "complete", "create", "build", "break", "mend", "fix", "open",
      "close", "enter", "exit", "move", "stop", "wait", "hurry", "sprint", "jump", "climb",
      "fall", "fly", "drive", "guide", "protect", "defend", "attack", "strike", "conquer", "rule"
    ];
    
    // Categorized words (subsets from our vocabulary)
    const greetings = ["hello", "welcome"];
    const roles = ["friend", "hero", "ally", "villain", "stranger"];
    const questWords = ["quest", "journey", "adventure", "mystery", "secret", "fate", "destiny", "fortune"];
    const actionVerbs = ["seek", "find", "explore", "protect", "challenge", "follow", "return", "begin", "start", "finish", "discover", "build", "attack", "conquer", "rule"];
    const adjectives = ["brave", "bold", "cunning", "wise", "curious", "dark", "light", "calm"];
    
    // NPC dialogue templates
    const npcTemplates = [
      "{greeting}, {role}. I {verb} a {adjective} {quest}.",
      "{role}, your {quest} is {adjective} and {adjective2}.",
      "I {verb} to {verb2} the {quest} of a {role}.",
      "Do you {verb} the {quest} with a {adjective} {role}?",
      "This {quest} will {verb} your {role} to {verb2}."
    ];
    
    // Player dialogue option templates
    const playerTemplates = [
      "Yes, I will {verb} the {quest}.",
      "No, I {verb} not the {quest}.",
      "Maybe, I should {verb} and {verb2} the {quest}.",
      "I {verb} your {quest} and will {verb2}."
    ];
    
    // Helper: choose a random element from an array.
    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }
    
    // Replace tokens in templates with words from the categorized arrays.
    function generateSentence(template) {
      return template.replace(/{(\w+)}/g, (match, token) => {
        switch(token) {
          case "greeting": return randomChoice(greetings);
          case "role": return randomChoice(roles);
          case "quest": return randomChoice(questWords);
          case "verb": return randomChoice(actionVerbs);
          case "verb2": return randomChoice(actionVerbs);
          case "adjective": return randomChoice(adjectives);
          case "adjective2": return randomChoice(adjectives);
          default: return "";
        }
      });
    }
    
    // NPC constructor – each NPC gets a randomly generated dialogue.
    function NPC(x, y) {
      this.x = x;
      this.y = y;
      this.size = 16;
      this.dialogue = generateSentence(randomChoice(npcTemplates));
    }
    
    // Create an array of NPCs spread across the world.
    let npcs = [];
    for(let i = 0; i < 20; i++){
      let npcX = Math.random() * 2000 - 1000;
      let npcY = Math.random() * 2000 - 1000;
      npcs.push(new NPC(npcX, npcY));
    }
    
    // Pickup items (coins, potions, keys)
    function Pickup(x, y, type) {
      this.x = x;
      this.y = y;
      this.size = 10;
      this.type = type;
    }
    let pickups = [];
    for(let i = 0; i < 30; i++){
      let pX = Math.random() * 2000 - 1000;
      let pY = Math.random() * 2000 - 1000;
      let types = ["coin", "potion", "key"];
      pickups.push(new Pickup(pX, pY, randomChoice(types)));
    }
    
    // Enemies – simple red blocks that slowly chase the player.
    function Enemy(x, y) {
      this.x = x;
      this.y = y;
      this.size = 16;
      this.speed = 1;
    }
    let enemies = [];
    for(let i = 0; i < 10; i++){
      let eX = Math.random() * 2000 - 1000;
      let eY = Math.random() * 2000 - 1000;
      enemies.push(new Enemy(eX, eY));
    }
    
    // Dialogue box elements
    const dialogueBox = document.getElementById('dialogueBox');
    const talkPrompt = document.getElementById('talkPrompt');
    
    // Current dialogue state variables
    let currentNPC = null;
    let currentDialogueOptions = [];
    
    // Keyboard handling
    let keys = {};
    window.addEventListener('keydown', function(e) {
      keys[e.key] = true;
      if(gameState === 'dialogue' && e.key === "Escape"){
        endDialogue();
      }
      if(gameState === 'game' && e.key.toLowerCase() === 'e' && currentNPC) {
        startDialogue(currentNPC);
      }
    });
    window.addEventListener('keyup', function(e) {
      keys[e.key] = false;
    });
    
    // Begin dialogue mode with the selected NPC.
    function startDialogue(npc) {
      gameState = 'dialogue';
      let npcDialogue = npc.dialogue;
      currentDialogueOptions = [
        generateSentence(randomChoice(playerTemplates)),
        generateSentence(randomChoice(playerTemplates))
      ];
      dialogueBox.innerHTML = "<p>" + npcDialogue + "</p>";
      currentDialogueOptions.forEach(option => {
        let div = document.createElement("div");
        div.className = "dialogue-option";
        div.innerText = option;
        div.addEventListener('click', function() {
          // For simplicity, selecting an option ends dialogue and updates NPC dialogue.
          npc.dialogue = generateSentence(randomChoice(npcTemplates));
          endDialogue();
        });
        dialogueBox.appendChild(div);
      });
      dialogueBox.style.display = "block";
    }
    
    // End dialogue mode and return to the game.
    function endDialogue() {
      gameState = 'game';
      dialogueBox.style.display = "none";
      dialogueBox.innerHTML = "";
      currentNPC = null;
    }
    
    // Update game objects.
    function update() {
      if(gameState === 'game') {
        if(keys["ArrowUp"] || keys["w"]) player.y -= player.speed;
        if(keys["ArrowDown"] || keys["s"]) player.y += player.speed;
        if(keys["ArrowLeft"] || keys["a"]) player.x -= player.speed;
        if(keys["ArrowRight"] || keys["d"]) player.x += player.speed;
      }
      // Center camera on the player.
      camera.x = player.x - canvas.width / 2;
      camera.y = player.y - canvas.height / 2;
      
      // Enemies move toward the player.
      enemies.forEach(enemy => {
        let dx = player.x - enemy.x;
        let dy = player.y - enemy.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if(dist > 0) {
          enemy.x += (dx/dist) * enemy.speed;
          enemy.y += (dy/dist) * enemy.speed;
        }
      });
    }
    
    // Check if the player is near an NPC to show the "E to talk" prompt.
    function checkNPCProximity() {
      currentNPC = null;
      npcs.forEach(npc => {
        let dx = npc.x - player.x;
        let dy = npc.y - player.y;
        if(Math.sqrt(dx*dx + dy*dy) < 30) {
          currentNPC = npc;
          talkPrompt.style.left = (npc.x - camera.x) + "px";
          talkPrompt.style.top = (npc.y - camera.y - 20) + "px";
          talkPrompt.style.display = "block";
        }
      });
      if(!currentNPC) {
        talkPrompt.style.display = "none";
      }
    }
    
    // Draw the game scene.
    function draw() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw pickups.
      pickups.forEach(pickup => {
        let screenX = pickup.x - camera.x;
        let screenY = pickup.y - camera.y;
        if(pickup.type === "coin") ctx.fillStyle = "yellow";
        else if(pickup.type === "potion") ctx.fillStyle = "blue";
        else if(pickup.type === "key") ctx.fillStyle = "orange";
        ctx.fillRect(screenX, screenY, pickup.size, pickup.size);
      });
      
      // Draw enemies.
      enemies.forEach(enemy => {
        let screenX = enemy.x - camera.x;
        let screenY = enemy.y - camera.y;
        ctx.fillStyle = "red";
        ctx.fillRect(screenX, screenY, enemy.size, enemy.size);
      });
      
      // Draw NPCs.
      npcs.forEach(npc => {
        let screenX = npc.x - camera.x;
        let screenY = npc.y - camera.y;
        ctx.fillStyle = "green";
        ctx.fillRect(screenX, screenY, npc.size, npc.size);
      });
      
      // Draw the player.
      let playerScreenX = player.x - camera.x;
      let playerScreenY = player.y - camera.y;
      ctx.fillStyle = "white";
      ctx.fillRect(playerScreenX, playerScreenY, player.size, player.size);
    }
    
    // Main game loop.
    function gameLoop() {
      update();
      checkNPCProximity();
      draw();
      requestAnimationFrame(gameLoop);
    }
    gameLoop();
    
    // Adjust canvas on window resize.
    window.addEventListener('resize', function(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>